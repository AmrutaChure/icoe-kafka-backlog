name: Auto-close Parent Issue

on:
  issues:
    types: [closed]

permissions:
  issues: write
  contents: read

jobs:
  check-parent-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Check permissions
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Test if we can read issues
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 1
              });
              console.log('âœ… Can read issues');
              
              // Test if we can read the current issue
              const { data: currentIssue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log('âœ… Can read current issue');
              
            } catch (error) {
              console.error('âŒ Permission test failed:', error.message);
              console.error('Token permissions:', process.env.GITHUB_TOKEN ? 'Token exists' : 'No token');
              throw error;
            }

      - name: Check if parent issue should be closed
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data: closedIssue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });

              console.log(`Processing closed issue #${closedIssue.number}: ${closedIssue.title}`);

              // Get all open issues to check which ones might be parents
              const { data: allIssues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              // Look for issues that reference this closed issue in their body (as task lists)
              const closedIssueNumber = context.payload.issue.number;
              
              for (const issue of allIssues) {
                if (!issue.body) continue;
                
                // Check if this issue has task list items that reference the closed issue
                const taskListRegex = /- \[[ x]\] .*#(\d+)/g;
                const taskMatches = [...issue.body.matchAll(taskListRegex)];
                
                // Also check for direct references
                const directReferenceRegex = /#(\d+)/g;
                const directMatches = [...issue.body.matchAll(directReferenceRegex)];
                
                const allReferences = [...taskMatches, ...directMatches].map(match => parseInt(match[1]));
                
                if (allReferences.includes(closedIssueNumber)) {
                  console.log(`Found parent issue #${issue.number} that references closed issue #${closedIssueNumber}`);
                  
                  // Get all unique issue numbers referenced in this parent issue
                  const referencedIssues = [...new Set(allReferences)];
                  
                  // Check status of all referenced issues
                  const issueStatuses = await Promise.all(
                    referencedIssues.map(async (issueNum) => {
                      try {
                        const { data: referencedIssue } = await github.rest.issues.get({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNum
                        });
                        return { number: issueNum, state: referencedIssue.state, title: referencedIssue.title };
                      } catch (error) {
                        console.log(`Could not fetch issue #${issueNum}:`, error.message);
                        return null;
                      }
                    })
                  );
                  
                  const validIssues = issueStatuses.filter(issue => issue !== null);
                  const openReferencedIssues = validIssues.filter(issue => issue.state === 'open');
                  
                  console.log(`Parent issue #${issue.number} has ${openReferencedIssues.length} open referenced issues out of ${validIssues.length} total`);
                  
                  if (openReferencedIssues.length === 0 && validIssues.length > 0) {
                    try {
                      // All referenced issues are closed, close the parent
                      await github.rest.issues.update({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issue.number,
                        state: 'closed'
                      });

                      // Add a comment explaining why it was closed
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issue.number,
                        body: `ðŸŽ‰ This issue has been automatically closed because all related sub-issues have been completed.\n\nCompleted sub-issues:\n${validIssues.map(subIssue => `- #${subIssue.number} ${subIssue.title}`).join('\n')}`
                      });

                      console.log(`Successfully closed parent issue #${issue.number}`);
                    } catch (updateError) {
                      console.error(`Failed to close parent issue #${issue.number}:`, updateError.message);
                    }
                  }
                }
              }
            } catch (error) {
              console.error('Workflow error:', error.message);
              console.error('Error details:', error);
            }
